{
  "version": 3,
  "sources": ["../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutPropertiesLoose.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectWithoutProperties.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js", "../../@trpc/react-query/src/internals/getQueryKey.ts", "../../@trpc/react-query/src/shared/proxy/decorationProxy.ts", "../../@trpc/react-query/src/internals/context.tsx", "../../@trpc/react-query/src/shared/proxy/utilsProxy.ts", "../../@trpc/react-query/src/shared/proxy/useQueriesProxy.ts", "../../@trpc/react-query/src/internals/getClientArgs.ts", "../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js", "../../@trpc/react-query/src/internals/trpcResult.ts", "../../@trpc/react-query/src/utils/createUtilityFunctions.ts", "../../@trpc/react-query/src/shared/hooks/createHooksInternal.tsx", "../../@trpc/react-query/src/shared/queryClient.ts", "../../@trpc/react-query/src/createTRPCReact.tsx", "../../@trpc/react-query/src/createTRPCQueryUtils.tsx"],
  "sourcesContent": ["function _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nmodule.exports = toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nmodule.exports = toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(e, r, t) {\n  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "var defineProperty = require(\"./defineProperty.js\");\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import { skipToken } from '@tanstack/react-query';\nimport {\n  isObject,\n  type DeepPartial,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type { DecoratedMutation, DecoratedQuery } from '../createTRPCReact';\nimport type { DecorateRouterRecord } from '../shared';\n\nexport type QueryType = 'any' | 'infinite' | 'query';\n\nexport type TRPCQueryKey = [\n  readonly string[],\n  { input?: unknown; type?: Exclude<QueryType, 'any'> }?,\n];\n\nexport type TRPCMutationKey = [readonly string[]]; // = [TRPCQueryKey[0]]\n\ntype ProcedureOrRouter =\n  | DecoratedMutation<any>\n  | DecoratedQuery<any>\n  | DecorateRouterRecord<any, any>;\n\n/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query.\n **/\nexport function getQueryKeyInternal(\n  path: readonly string[],\n  input: unknown,\n  type: QueryType,\n): TRPCQueryKey {\n  // Construct a query key that is easy to destructure and flexible for\n  // partial selecting etc.\n  // https://github.com/trpc/trpc/issues/3128\n\n  // some parts of the path may be dot-separated, split them up\n  const splitPath = path.flatMap((part) => part.split('.'));\n\n  if (!input && (!type || type === 'any')) {\n    // this matches also all mutations (see `getMutationKeyInternal`)\n\n    // for `utils.invalidate()` to match all queries (including vanilla react-query)\n    // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n    return splitPath.length ? [splitPath] : ([] as unknown as TRPCQueryKey);\n  }\n\n  if (\n    type === 'infinite' &&\n    isObject(input) &&\n    ('direction' in input || 'cursor' in input)\n  ) {\n    const {\n      cursor: _,\n      direction: __,\n      ...inputWithoutCursorAndDirection\n    } = input;\n    return [\n      splitPath,\n      {\n        input: inputWithoutCursorAndDirection,\n        type: 'infinite',\n      },\n    ];\n  }\n  return [\n    splitPath,\n    {\n      ...(typeof input !== 'undefined' &&\n        input !== skipToken && { input: input }),\n      ...(type && type !== 'any' && { type: type }),\n    },\n  ];\n}\n\nexport function getMutationKeyInternal(path: readonly string[]) {\n  return getQueryKeyInternal(path, undefined, 'any') as TRPCMutationKey;\n}\n\ntype GetInfiniteQueryInput<\n  TProcedureInput,\n  TInputWithoutCursorAndDirection = Omit<\n    TProcedureInput,\n    'cursor' | 'direction'\n  >,\n> = keyof TInputWithoutCursorAndDirection extends never\n  ? undefined\n  : DeepPartial<TInputWithoutCursorAndDirection> | undefined;\n\n/** @internal */\nexport type GetQueryProcedureInput<TProcedureInput> = TProcedureInput extends {\n  cursor?: any;\n}\n  ? GetInfiniteQueryInput<TProcedureInput>\n  : DeepPartial<TProcedureInput> | undefined;\n\ntype GetParams<TProcedureOrRouter extends ProcedureOrRouter> =\n  TProcedureOrRouter extends DecoratedQuery<infer $Def>\n    ? [input?: GetQueryProcedureInput<$Def['input']>, type?: QueryType]\n    : [];\n\n/**\n * Method to extract the query key for a procedure\n * @param procedureOrRouter - procedure or AnyRouter\n * @param input - input to procedureOrRouter\n * @param type - defaults to `any`\n * @see https://trpc.io/docs/v11/getQueryKey\n */\nexport function getQueryKey<TProcedureOrRouter extends ProcedureOrRouter>(\n  procedureOrRouter: TProcedureOrRouter,\n  ..._params: GetParams<TProcedureOrRouter>\n) {\n  const [input, type] = _params;\n\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedureOrRouter._def().path as string[];\n  const queryKey = getQueryKeyInternal(path, input, type ?? 'any');\n  return queryKey;\n}\n\n// TODO: look over if we can't use a single type\nexport type QueryKeyKnown<TInput, TType extends Exclude<QueryType, 'any'>> = [\n  string[],\n  { input?: GetQueryProcedureInput<TInput>; type: TType }?,\n];\n\n/**\n * Method to extract the mutation key for a procedure\n * @param procedure - procedure\n * @see https://trpc.io/docs/v11/getQueryKey#mutations\n */\nexport function getMutationKey<TProcedure extends DecoratedMutation<any>>(\n  procedure: TProcedure,\n) {\n  // @ts-expect-error - we don't expose _def on the type layer\n  const path = procedure._def().path as string[];\n  return getMutationKeyInternal(path);\n}\n", "import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport type { CreateReactQueryHooks } from '../hooks/createHooksInternal';\n\n/**\n * Create proxy for decorating procedures\n * @internal\n */\nexport function createReactDecoration<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(hooks: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  return createRecursiveProxy(({ path, args }) => {\n    const pathCopy = [...path];\n\n    // The last arg is for instance `.useMutation` or `.useQuery()`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastArg = pathCopy.pop()!;\n\n    if (lastArg === 'useMutation') {\n      return (hooks as any)[lastArg](pathCopy, ...args);\n    }\n\n    if (lastArg === '_def') {\n      return {\n        path: pathCopy,\n      };\n    }\n\n    const [input, ...rest] = args;\n    const opts = rest[0] ?? {};\n\n    return (hooks as any)[lastArg](pathCopy, input, opts);\n  });\n}\n", "import type {\n  CancelOptions,\n  FetchInfiniteQueryOptions,\n  FetchQueryOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  MutationOptions,\n  QueryClient,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  Updater,\n} from '@tanstack/react-query';\nimport type {\n  TRPCClient,\n  TRPCClientError,\n  TRPCRequestOptions,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type {\n  AnyClientTypes,\n  AnyRouter,\n  DistributiveOmit,\n} from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  ExtractCursorType,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n} from '../shared';\nimport type { TRPCMutationKey, TRPCQueryKey } from './getQueryKey';\n\ninterface TRPCUseUtilsOptions {\n  /**\n   * tRPC-related options\n   */\n  trpc?: TRPCRequestOptions;\n}\nexport interface TRPCFetchQueryOptions<TOutput, TError>\n  extends DistributiveOmit<FetchQueryOptions<TOutput, TError>, 'queryKey'>,\n    TRPCUseUtilsOptions {\n  //\n}\n\nexport type TRPCFetchInfiniteQueryOptions<TInput, TOutput, TError> =\n  DistributiveOmit<\n    FetchInfiniteQueryOptions<\n      TOutput,\n      TError,\n      TOutput,\n      TRPCQueryKey,\n      ExtractCursorType<TInput>\n    >,\n    'queryKey' | 'initialPageParam'\n  > &\n    TRPCUseUtilsOptions & {\n      initialCursor?: ExtractCursorType<TInput>;\n    };\n\n/** @internal */\nexport type SSRState = 'mounted' | 'mounting' | 'prepass' | false;\n\nexport interface TRPCContextPropsBase<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCUntypedClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * @deprecated pass abortOnUnmount to `createTRPCReact` instead\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n\n/**\n * @internal\n */\nexport type DecoratedTRPCContextProps<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = TRPCContextPropsBase<TRouter, TSSRContext> & {\n  client: TRPCClient<TRouter>;\n};\n\nexport interface TRPCContextProps<TRouter extends AnyRouter, TSSRContext>\n  extends TRPCContextPropsBase<TRouter, TSSRContext> {\n  /**\n   * The react-query `QueryClient`\n   */\n  queryClient: QueryClient;\n}\n\nexport const contextProps: (keyof TRPCContextPropsBase<any, any>)[] = [\n  'client',\n  'ssrContext',\n  'ssrState',\n  'abortOnUnmount',\n];\n\n/**\n * @internal\n */\nexport interface TRPCContextState<\n  TRouter extends AnyRouter,\n  TSSRContext = undefined,\n> extends Required<TRPCContextProps<TRouter, TSSRContext>>,\n    TRPCQueryUtils<TRouter> {}\n\n/**\n * @internal\n */\nexport interface TRPCQueryUtils<TRouter extends AnyRouter> {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  queryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCQueryOptionsIn<\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCQueryOptionsOut<\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: UndefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n  infiniteQueryOptions(\n    path: readonly string[], // <-- look into if needed\n    queryKey: TRPCQueryKey,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      unknown,\n      unknown,\n      unknown,\n      TRPCClientError<AnyClientTypes>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    unknown,\n    unknown,\n    unknown,\n    TRPCClientError<AnyClientTypes>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<InfiniteData<unknown, unknown>>;\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/prefetching\n   */\n  prefetchQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfiniteQuery: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      unknown,\n      unknown,\n      TRPCClientError<TRouter>\n    >,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureQueryData: (\n    queryKey: TRPCQueryKey,\n    opts?: TRPCFetchQueryOptions<unknown, TRPCClientError<TRouter>>,\n  ) => Promise<unknown>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidateQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: InvalidateQueryFilters<TRPCQueryKey>,\n    options?: InvalidateOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  resetQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: QueryFilters<TRPCQueryKey>,\n    options?: ResetOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetchQueries: (\n    queryKey: TRPCQueryKey,\n    filters?: RefetchQueryFilters<TRPCQueryKey>,\n    options?: RefetchOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-cancellation\n   */\n  cancelQuery: (\n    queryKey: TRPCQueryKey,\n    options?: CancelOptions,\n  ) => Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetqueriesdata\n   */\n  setQueriesData: (\n    queryKey: TRPCQueryKey,\n    filters: QueryFilters,\n    updater: Updater<unknown, unknown>,\n    options?: SetDataOptions,\n  ) => [QueryKey, unknown][];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getQueryData: (queryKey: TRPCQueryKey) => unknown;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n    updater: Updater<\n      InfiniteData<unknown> | undefined,\n      InfiniteData<unknown> | undefined\n    >,\n    options?: SetDataOptions,\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteQueryData: (\n    queryKey: TRPCQueryKey,\n  ) => InfiniteData<unknown> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient/#queryclientsetmutationdefaults\n   */\n  setMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n    options:\n      | MutationOptions\n      | ((args: {\n          canonicalMutationFn: (input: unknown) => Promise<unknown>;\n        }) => MutationOptions),\n  ) => void;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientgetmutationdefaults\n   */\n  getMutationDefaults: (\n    mutationKey: TRPCMutationKey,\n  ) => MutationOptions | undefined;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/reference/QueryClient#queryclientismutating\n   */\n  isMutating: (filters: { mutationKey: TRPCMutationKey }) => number;\n}\nexport const TRPCContext = React.createContext?.(null as any);\n", "import type {\n  CancelOptions,\n  InfiniteData,\n  InvalidateOptions,\n  InvalidateQueryFilters,\n  Query,\n  QueryFilters,\n  QueryKey,\n  RefetchOptions,\n  RefetchQueryFilters,\n  ResetOptions,\n  SetDataOptions,\n  SkipToken,\n  Updater,\n} from '@tanstack/react-query';\nimport type { TRPCClientError } from '@trpc/client';\nimport { createTRPCClientProxy } from '@trpc/client';\nimport type {\n  AnyMutationProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  DeepPartial,\n  inferProcedureInput,\n  inferProcedureOutput,\n  inferTransformedProcedureOutput,\n  ProtectedIntersection,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport {\n  createFlatProxy,\n  createRecursiveProxy,\n} from '@trpc/server/unstable-core-do-not-import';\nimport type {\n  DecoratedTRPCContextProps,\n  TRPCContextState,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n  TRPCQueryUtils,\n} from '../../internals/context';\nimport { contextProps } from '../../internals/context';\nimport type { QueryKeyKnown, QueryType } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport type { InferMutationOptions } from '../../utils/inferReactQueryProcedure';\nimport type { ExtractCursorType } from '../hooks/types';\nimport type {\n  DefinedTRPCInfiniteQueryOptionsIn,\n  DefinedTRPCInfiniteQueryOptionsOut,\n  DefinedTRPCQueryOptionsIn,\n  DefinedTRPCQueryOptionsOut,\n  UndefinedTRPCInfiniteQueryOptionsIn,\n  UndefinedTRPCInfiniteQueryOptionsOut,\n  UndefinedTRPCQueryOptionsIn,\n  UndefinedTRPCQueryOptionsOut,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsIn,\n  UnusedSkipTokenTRPCInfiniteQueryOptionsOut,\n  UnusedSkipTokenTRPCQueryOptionsIn,\n  UnusedSkipTokenTRPCQueryOptionsOut,\n} from '../types';\n\nexport type DecorateQueryProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = {\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UnusedSkipTokenTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCQueryOptionsOut<\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/queryOptions#queryoptions\n   */\n  queryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCQueryOptionsIn<\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCQueryOptionsOut<TQueryFnData, TData, TRPCClientError<TRoot>>;\n\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts: DefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): DefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure>,\n    opts: UnusedSkipTokenTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UnusedSkipTokenTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n  /**\n   * @see https://tanstack.com/query/latest/docs/framework/react/reference/infiniteQueryOptions#infinitequeryoptions\n   */\n  infiniteQueryOptions<\n    TQueryFnData extends inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData = TQueryFnData,\n  >(\n    input: inferProcedureInput<TProcedure> | SkipToken,\n    opts?: UndefinedTRPCInfiniteQueryOptionsIn<\n      inferProcedureInput<TProcedure>,\n      TQueryFnData,\n      TData,\n      TRPCClientError<TRoot>\n    >,\n  ): UndefinedTRPCInfiniteQueryOptionsOut<\n    inferProcedureInput<TProcedure>,\n    TQueryFnData,\n    TData,\n    TRPCClientError<TRoot>\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchquery\n   */\n  fetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientfetchinfinitequery\n   */\n  fetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<\n    InfiniteData<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n    >\n  >;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchquery\n   */\n  prefetch(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientprefetchinfinitequery\n   */\n  prefetchInfinite(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchInfiniteQueryOptions<\n      inferProcedureInput<TProcedure>,\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientensurequerydata\n   */\n  ensureData(\n    input: inferProcedureInput<TProcedure>,\n    opts?: TRPCFetchQueryOptions<\n      inferTransformedProcedureOutput<TRoot, TProcedure>,\n      TRPCClientError<TRoot>\n    >,\n  ): Promise<inferTransformedProcedureOutput<TRoot, TProcedure>>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientinvalidatequeries\n   */\n  invalidate(\n    input?: DeepPartial<inferProcedureInput<TProcedure>>,\n    filters?: Omit<InvalidateQueryFilters, 'predicate'> & {\n      predicate?: (\n        query: Query<\n          inferProcedureOutput<TProcedure>,\n          TRPCClientError<TRoot>,\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          QueryKeyKnown<\n            inferProcedureInput<TProcedure>,\n            inferProcedureInput<TProcedure> extends { cursor?: any } | void\n              ? 'infinite'\n              : 'query'\n          >\n        >,\n      ) => boolean;\n    },\n    options?: InvalidateOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientrefetchqueries\n   */\n  refetch(\n    input?: inferProcedureInput<TProcedure>,\n    filters?: RefetchQueryFilters,\n    options?: RefetchOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientcancelqueries\n   */\n  cancel(\n    input?: inferProcedureInput<TProcedure>,\n    options?: CancelOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientresetqueries\n   */\n  reset(\n    input?: inferProcedureInput<TProcedure>,\n    options?: ResetOptions,\n  ): Promise<void>;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setQueriesData(\n    /**\n     * The input of the procedure\n     */\n    input: inferProcedureInput<TProcedure>,\n    filters: QueryFilters,\n    updater: Updater<\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined,\n      inferTransformedProcedureOutput<TRoot, TProcedure> | undefined\n    >,\n    options?: SetDataOptions,\n  ): [QueryKey, inferTransformedProcedureOutput<TRoot, TProcedure>];\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientsetquerydata\n   */\n  setInfiniteData(\n    input: inferProcedureInput<TProcedure>,\n    updater: Updater<\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined,\n      | InfiniteData<\n          inferTransformedProcedureOutput<TRoot, TProcedure>,\n          NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n        >\n      | undefined\n    >,\n    options?: SetDataOptions,\n  ): void;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getData(\n    input?: inferProcedureInput<TProcedure>,\n  ): inferTransformedProcedureOutput<TRoot, TProcedure> | undefined;\n\n  /**\n   * @see https://tanstack.com/query/v5/docs/reference/QueryClient#queryclientgetquerydata\n   */\n  getInfiniteData(\n    input?: inferProcedureInput<TProcedure>,\n  ):\n    | InfiniteData<\n        inferTransformedProcedureOutput<TRoot, TProcedure>,\n        NonNullable<ExtractCursorType<inferProcedureInput<TProcedure>>> | null\n      >\n    | undefined;\n};\n\ntype DecorateMutationProcedure<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyMutationProcedure,\n> = {\n  setMutationDefaults<TMeta = unknown>(\n    options:\n      | InferMutationOptions<TRoot, TProcedure, TMeta>\n      | ((args: {\n          canonicalMutationFn: NonNullable<\n            InferMutationOptions<TRoot, TProcedure>['mutationFn']\n          >;\n        }) => InferMutationOptions<TRoot, TProcedure, TMeta>),\n  ): void;\n\n  getMutationDefaults(): InferMutationOptions<TRoot, TProcedure> | undefined;\n\n  isMutating(): number;\n};\n\n/**\n * this is the type that is used to add in procedures that can be used on\n * an entire router\n */\ntype DecorateRouter = {\n  /**\n   * Invalidate the full router\n   * @see https://trpc.io/docs/v10/useContext#query-invalidation\n   * @see https://tanstack.com/query/v5/docs/framework/react/guides/query-invalidation\n   */\n  invalidate(\n    input?: undefined,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions,\n  ): Promise<void>;\n};\n\n/**\n * @internal\n */\nexport type DecoratedProcedureUtilsRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = DecorateRouter & {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? DecorateQueryProcedure<TRoot, $Value>\n      : $Value extends AnyMutationProcedure\n        ? DecorateMutationProcedure<TRoot, $Value>\n        : $Value extends RouterRecord\n          ? DecoratedProcedureUtilsRecord<TRoot, $Value> & DecorateRouter\n          : never\n    : never;\n}; // Add functions that should be available at utils root\n\ntype AnyDecoratedProcedure = DecorateQueryProcedure<any, any> &\n  DecorateMutationProcedure<any, any>;\n\nexport type CreateReactUtils<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  DecoratedTRPCContextProps<TRouter, TSSRContext>,\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\nexport type CreateQueryUtils<TRouter extends AnyRouter> =\n  DecoratedProcedureUtilsRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n\nexport const getQueryType = (\n  utilName: keyof AnyDecoratedProcedure,\n): QueryType => {\n  switch (utilName) {\n    case 'queryOptions':\n    case 'fetch':\n    case 'ensureData':\n    case 'prefetch':\n    case 'getData':\n    case 'setData':\n    case 'setQueriesData':\n      return 'query';\n\n    case 'infiniteQueryOptions':\n    case 'fetchInfinite':\n    case 'prefetchInfinite':\n    case 'getInfiniteData':\n    case 'setInfiniteData':\n      return 'infinite';\n\n    case 'setMutationDefaults':\n    case 'getMutationDefaults':\n    case 'isMutating':\n    case 'cancel':\n    case 'invalidate':\n    case 'refetch':\n    case 'reset':\n      return 'any';\n  }\n};\n\n/**\n * @internal\n */\nfunction createRecursiveUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n) {\n  return createRecursiveProxy<CreateQueryUtils<TRouter>>((opts) => {\n    const path = [...opts.path];\n    const utilName = path.pop() as keyof AnyDecoratedProcedure;\n    const args = [...opts.args] as Parameters<\n      AnyDecoratedProcedure[typeof utilName]\n    >;\n    const input = args.shift(); // args can now be spread when input removed\n    const queryType = getQueryType(utilName);\n    const queryKey = getQueryKeyInternal(path, input, queryType);\n\n    const contextMap: Record<keyof AnyDecoratedProcedure, () => unknown> = {\n      infiniteQueryOptions: () =>\n        context.infiniteQueryOptions(path, queryKey, args[0]),\n      queryOptions: () => context.queryOptions(path, queryKey, ...args),\n      /**\n       * DecorateQueryProcedure\n       */\n      fetch: () => context.fetchQuery(queryKey, ...args),\n      fetchInfinite: () => context.fetchInfiniteQuery(queryKey, args[0]),\n      prefetch: () => context.prefetchQuery(queryKey, ...args),\n      prefetchInfinite: () => context.prefetchInfiniteQuery(queryKey, args[0]),\n      ensureData: () => context.ensureQueryData(queryKey, ...args),\n      invalidate: () => context.invalidateQueries(queryKey, ...args),\n      reset: () => context.resetQueries(queryKey, ...args),\n      refetch: () => context.refetchQueries(queryKey, ...args),\n      cancel: () => context.cancelQuery(queryKey, ...args),\n      setData: () => {\n        context.setQueryData(queryKey, args[0], args[1]);\n      },\n      setQueriesData: () =>\n        context.setQueriesData(queryKey, args[0], args[1], args[2]),\n      setInfiniteData: () => {\n        context.setInfiniteQueryData(queryKey, args[0], args[1]);\n      },\n      getData: () => context.getQueryData(queryKey),\n      getInfiniteData: () => context.getInfiniteQueryData(queryKey),\n      /**\n       * DecorateMutationProcedure\n       */\n      setMutationDefaults: () =>\n        context.setMutationDefaults(getMutationKeyInternal(path), input),\n      getMutationDefaults: () =>\n        context.getMutationDefaults(getMutationKeyInternal(path)),\n      isMutating: () =>\n        context.isMutating({ mutationKey: getMutationKeyInternal(path) }),\n    };\n\n    return contextMap[utilName]();\n  });\n}\n\n/**\n * @internal\n */\nexport function createReactQueryUtils<TRouter extends AnyRouter, TSSRContext>(\n  context: TRPCContextState<AnyRouter, TSSRContext>,\n) {\n  type CreateReactUtilsReturnType = CreateReactUtils<TRouter, TSSRContext>;\n\n  const clientProxy = createTRPCClientProxy(context.client);\n\n  const proxy = createRecursiveUtilsProxy(\n    context,\n  ) as CreateReactUtilsReturnType;\n\n  return createFlatProxy<CreateReactUtilsReturnType>((key) => {\n    const contextName = key as (typeof contextProps)[number];\n    if (contextName === 'client') {\n      return clientProxy;\n    }\n    if (contextProps.includes(contextName)) {\n      return context[contextName];\n    }\n\n    return proxy[key];\n  });\n}\n\n/**\n * @internal\n */\nexport function createQueryUtilsProxy<TRouter extends AnyRouter>(\n  context: TRPCQueryUtils<TRouter>,\n): CreateQueryUtils<TRouter> {\n  return createRecursiveUtilsProxy(context);\n}\n", "import type { QueryOptions } from '@tanstack/react-query';\nimport type { TRPCClient } from '@trpc/client';\nimport {\n  getUntypedClient,\n  TRPCUntypedClient,\n  type TRPCClientError,\n} from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyQueryProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  RouterRecord,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createRecursiveProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { getQueryKeyInternal } from '../../internals/getQueryKey';\nimport type {\n  TrpcQueryOptionsForUseQueries,\n  TrpcQueryOptionsForUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport type { TRPCUseQueryBaseOptions } from '../hooks/types';\n\ntype GetQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\ntype GetSuspenseQueryOptions<\n  TRoot extends AnyRootTypes,\n  TProcedure extends AnyQueryProcedure,\n> = <TData = inferTransformedProcedureOutput<TRoot, TProcedure>>(\n  input: inferProcedureInput<TProcedure>,\n  opts?: TrpcQueryOptionsForUseSuspenseQueries<\n    inferTransformedProcedureOutput<TRoot, TProcedure>,\n    TData,\n    TRPCClientError<TRoot>\n  >,\n) => TrpcQueryOptionsForUseSuspenseQueries<\n  inferTransformedProcedureOutput<TRoot, TProcedure>,\n  TData,\n  TRPCClientError<TRoot>\n>;\n\n/**\n * @internal\n */\nexport type UseSuspenseQueriesProcedureRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyQueryProcedure\n      ? GetSuspenseQueryOptions<TRoot, $Value>\n      : $Value extends RouterRecord\n        ? UseSuspenseQueriesProcedureRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * Create proxy for `useQueries` options\n * @internal\n */\nexport function createUseQueries<TRouter extends AnyRouter>(\n  client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>,\n) {\n  const untypedClient: TRPCUntypedClient<TRouter> =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return createRecursiveProxy<\n    UseQueriesProcedureRecord<\n      TRouter['_def']['_config']['$types'],\n      TRouter['_def']['record']\n    >\n  >((opts) => {\n    const arrayPath = opts.path;\n    const dotPath = arrayPath.join('.');\n    const [input, _opts] = opts.args as [\n      unknown,\n      Partial<QueryOptions> & TRPCUseQueryBaseOptions,\n    ];\n\n    const options: QueryOptions = {\n      queryKey: getQueryKeyInternal(arrayPath, input, 'query'),\n      queryFn: () => {\n        return untypedClient.query(dotPath, input, _opts?.trpc);\n      },\n      ..._opts,\n    };\n\n    return options;\n  });\n}\n", "import type { TRPCQueryKey } from './getQueryKey';\n\n/**\n * @internal\n */\nexport function getClientArgs<TOptions>(\n  queryKey: TRPCQueryKey,\n  opts: TOptions,\n  infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  },\n) {\n  const path = queryKey[0];\n  let input = queryKey[1]?.input;\n  if (infiniteParams) {\n    input = {\n      ...(input ?? {}),\n      ...(infiniteParams.pageParam ? { cursor: infiniteParams.pageParam } : {}),\n      direction: infiniteParams.direction,\n    };\n  }\n  return [path.join('.'), input, (opts as any)?.trpc] as const;\n}\n", "function _asyncIterator(r) {\n  var n,\n    t,\n    o,\n    e = 2;\n  for (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n    if (t && null != (n = r[t])) return n.call(r);\n    if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n    t = \"@@asyncIterator\", o = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(r) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var n = r.done;\n    return Promise.resolve(r.value).then(function (r) {\n      return {\n        value: r,\n        done: n\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(r) {\n    this.s = r, this.n = r.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.resolve({\n        value: r,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(r) {\n      var n = this.s[\"return\"];\n      return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(r);\n}\nmodule.exports = _asyncIterator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;", "import type { QueryClient } from '@tanstack/react-query';\nimport * as React from 'react';\nimport type { TRPCQueryOptionsResult } from '../shared';\nimport type { TRPCHookResult } from '../shared/hooks/types';\nimport type { TRPCQueryKey } from './getQueryKey';\n\nexport function createTRPCOptionsResult(value: {\n  path: readonly string[];\n}): TRPCQueryOptionsResult['trpc'] {\n  const path = value.path.join('.');\n\n  return {\n    path,\n  };\n}\n\n/**\n * Makes a stable reference of the `trpc` prop\n */\nexport function useHookResult(value: {\n  path: readonly string[];\n}): TRPCHookResult['trpc'] {\n  const result = createTRPCOptionsResult(value);\n  return React.useMemo(() => result, [result]);\n}\n\n/**\n * @internal\n */\nexport async function buildQueryFromAsyncIterable(\n  asyncIterable: AsyncIterable<unknown>,\n  queryClient: QueryClient,\n  queryKey: TRPCQueryKey,\n) {\n  const queryCache = queryClient.getQueryCache();\n\n  const query = queryCache.build(queryClient, {\n    queryKey,\n  });\n\n  query.setState({\n    data: [],\n    status: 'success',\n  });\n\n  const aggregate: unknown[] = [];\n  for await (const value of asyncIterable) {\n    aggregate.push(value);\n\n    query.setState({\n      data: [...aggregate],\n    });\n  }\n  return aggregate;\n}\n", "import type { QueryFunctionContext } from '@tanstack/react-query';\nimport {\n  infiniteQueryOptions,\n  queryOptions,\n  skipToken,\n  type QueryClient,\n} from '@tanstack/react-query';\nimport type { TRPCClient, TRPCClientError } from '@trpc/client';\nimport { getUntypedClient, TRPCUntypedClient } from '@trpc/client';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport type { AnyClientTypes } from '@trpc/server/unstable-core-do-not-import/clientish/inferrable';\nimport { getClientArgs } from '../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  createTRPCOptionsResult,\n} from '../internals/trpcResult';\nimport type { DefinedTRPCQueryOptionsOut } from '../shared';\nimport { type TRPCQueryUtils } from '../shared';\n\nexport interface CreateQueryUtilsOptions<TRouter extends AnyRouter> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter> | TRPCUntypedClient<TRouter>;\n  /**\n   * The `QueryClient` from `react-query`\n   */\n  queryClient: QueryClient;\n}\n\n/**\n * Creates a set of utility functions that can be used to interact with `react-query`\n * @param opts the `TRPCClient` and `QueryClient` to use\n * @returns a set of utility functions that can be used to interact with `react-query`\n * @internal\n */\nexport function createUtilityFunctions<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n): TRPCQueryUtils<TRouter> {\n  const { client, queryClient } = opts;\n  const untypedClient =\n    client instanceof TRPCUntypedClient ? client : getUntypedClient(client);\n\n  return {\n    infiniteQueryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam,\n          }),\n        );\n\n        return result;\n      };\n\n      return Object.assign(\n        infiniteQueryOptions({\n          ...opts,\n          initialData: opts?.initialData as any,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n          initialPageParam: (opts?.initialCursor as any) ?? null,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      );\n    },\n\n    queryOptions: (path, queryKey, opts) => {\n      const inputIsSkipToken = queryKey[1]?.input === skipToken;\n\n      const queryFn = async (\n        queryFnContext: QueryFunctionContext<TRPCQueryKey>,\n      ): Promise<unknown> => {\n        const actualOpts = {\n          ...opts,\n          trpc: {\n            ...opts?.trpc,\n            ...(opts?.trpc?.abortOnUnmount\n              ? { signal: queryFnContext.signal }\n              : { signal: null }),\n          },\n        };\n\n        const result = await untypedClient.query(\n          ...getClientArgs(queryKey, actualOpts),\n        );\n\n        if (isAsyncIterable(result)) {\n          return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n\n        return result;\n      };\n\n      return Object.assign(\n        queryOptions({\n          ...opts,\n          initialData: opts?.initialData,\n          queryKey,\n          queryFn: inputIsSkipToken ? skipToken : queryFn,\n        }),\n        { trpc: createTRPCOptionsResult({ path }) },\n      ) as DefinedTRPCQueryOptionsOut<\n        unknown,\n        unknown,\n        TRPCClientError<AnyClientTypes>\n      >;\n    },\n\n    fetchQuery: (queryKey, opts) => {\n      return queryClient.fetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    fetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.fetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    prefetchQuery: (queryKey, opts) => {\n      return queryClient.prefetchQuery({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    prefetchInfiniteQuery: (queryKey, opts) => {\n      return queryClient.prefetchInfiniteQuery({\n        ...opts,\n        queryKey,\n        queryFn: ({ pageParam, direction }) => {\n          return untypedClient.query(\n            ...getClientArgs(queryKey, opts, { pageParam, direction }),\n          );\n        },\n        initialPageParam: opts?.initialCursor ?? null,\n      });\n    },\n\n    ensureQueryData: (queryKey, opts) => {\n      return queryClient.ensureQueryData({\n        ...opts,\n        queryKey,\n        queryFn: () => untypedClient.query(...getClientArgs(queryKey, opts)),\n      });\n    },\n\n    invalidateQueries: (queryKey, filters, options) => {\n      return queryClient.invalidateQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n    resetQueries: (queryKey, filters, options) => {\n      return queryClient.resetQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    refetchQueries: (queryKey, filters, options) => {\n      return queryClient.refetchQueries(\n        {\n          ...filters,\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    cancelQuery: (queryKey, options) => {\n      return queryClient.cancelQueries(\n        {\n          queryKey,\n        },\n        options,\n      );\n    },\n\n    setQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    // eslint-disable-next-line max-params\n    setQueriesData: (queryKey, filters, updater, options) => {\n      return queryClient.setQueriesData(\n        {\n          ...filters,\n          queryKey,\n        },\n        updater,\n        options,\n      );\n    },\n\n    getQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setInfiniteQueryData: (queryKey, updater, options) => {\n      return queryClient.setQueryData(queryKey, updater as any, options);\n    },\n\n    getInfiniteQueryData: (queryKey) => {\n      return queryClient.getQueryData(queryKey);\n    },\n\n    setMutationDefaults: (mutationKey, options) => {\n      const path = mutationKey[0];\n      const canonicalMutationFn = (input: unknown) => {\n        return untypedClient.mutation(\n          ...getClientArgs([path, { input }], opts),\n        );\n      };\n      return queryClient.setMutationDefaults(\n        mutationKey,\n        typeof options === 'function'\n          ? options({ canonicalMutationFn })\n          : options,\n      );\n    },\n\n    getMutationDefaults: (mutationKey) => {\n      return queryClient.getMutationDefaults(mutationKey);\n    },\n\n    isMutating: (filters) => {\n      return queryClient.isMutating({\n        ...filters,\n        exact: true,\n      });\n    },\n  };\n}\n", "// TODO: Look into fixing react-compiler support\n/* eslint-disable react-hooks/react-compiler */\nimport {\n  useInfiniteQuery as __useInfiniteQuery,\n  useMutation as __useMutation,\n  usePrefetchInfiniteQuery as __usePrefetchInfiniteQuery,\n  useQueries as __useQueries,\n  useQuery as __useQuery,\n  useSuspenseInfiniteQuery as __useSuspenseInfiniteQuery,\n  useSuspenseQueries as __useSuspenseQueries,\n  useSuspenseQuery as __useSuspenseQuery,\n  usePrefetchQuery as _usePrefetchQuery,\n  hashKey,\n  skipToken,\n} from '@tanstack/react-query';\nimport type { TRPCClientErrorLike } from '@trpc/client';\nimport {\n  createTRPCClient,\n  getUntypedClient,\n  TRPCUntypedClient,\n} from '@trpc/client';\nimport type { Unsubscribable } from '@trpc/server/observable';\nimport type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type { SSRState, TRPCContextState } from '../../internals/context';\nimport { TRPCContext } from '../../internals/context';\nimport { getClientArgs } from '../../internals/getClientArgs';\nimport type { TRPCQueryKey } from '../../internals/getQueryKey';\nimport {\n  getMutationKeyInternal,\n  getQueryKeyInternal,\n} from '../../internals/getQueryKey';\nimport {\n  buildQueryFromAsyncIterable,\n  useHookResult,\n} from '../../internals/trpcResult';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from '../../internals/useQueries';\nimport { createUtilityFunctions } from '../../utils/createUtilityFunctions';\nimport { createUseQueries } from '../proxy/useQueriesProxy';\nimport type { CreateTRPCReactOptions, UseMutationOverride } from '../types';\nimport type {\n  TRPCProvider,\n  TRPCQueryOptions,\n  TRPCSubscriptionConnectingResult,\n  TRPCSubscriptionIdleResult,\n  TRPCSubscriptionResult,\n  UseTRPCInfiniteQueryOptions,\n  UseTRPCInfiniteQueryResult,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCPrefetchInfiniteQueryOptions,\n  UseTRPCPrefetchQueryOptions,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseInfiniteQueryOptions,\n  UseTRPCSuspenseInfiniteQueryResult,\n  UseTRPCSuspenseQueryOptions,\n  UseTRPCSuspenseQueryResult,\n} from './types';\n\nconst trackResult = <T extends object>(\n  result: T,\n  onTrackResult: (key: keyof T) => void,\n): T => {\n  const trackedResult = new Proxy(result, {\n    get(target, prop) {\n      onTrackResult(prop as keyof T);\n      return target[prop as keyof T];\n    },\n  });\n\n  return trackedResult;\n};\n\n/**\n * @internal\n */\nexport function createRootHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(config?: CreateTRPCReactOptions<TRouter>) {\n  const mutationSuccessOverride: UseMutationOverride['onSuccess'] =\n    config?.overrides?.useMutation?.onSuccess ??\n    ((options) => options.originalFn());\n\n  type TError = TRPCClientErrorLike<TRouter>;\n\n  type ProviderContext = TRPCContextState<TRouter, TSSRContext>;\n\n  const Context = (config?.context ??\n    TRPCContext) as React.Context<ProviderContext>;\n\n  const createClient = createTRPCClient<TRouter>;\n\n  const TRPCProvider: TRPCProvider<TRouter, TSSRContext> = (props) => {\n    const { abortOnUnmount = false, queryClient, ssrContext } = props;\n    const [ssrState, setSSRState] = React.useState<SSRState>(\n      props.ssrState ?? false,\n    );\n\n    const client: TRPCUntypedClient<TRouter> =\n      props.client instanceof TRPCUntypedClient\n        ? props.client\n        : getUntypedClient(props.client);\n\n    const fns = React.useMemo(\n      () =>\n        createUtilityFunctions({\n          client,\n          queryClient,\n        }),\n      [client, queryClient],\n    );\n\n    const contextValue = React.useMemo<ProviderContext>(\n      () => ({\n        abortOnUnmount,\n        queryClient,\n        client,\n        ssrContext: ssrContext ?? null,\n        ssrState,\n        ...fns,\n      }),\n      [abortOnUnmount, client, fns, queryClient, ssrContext, ssrState],\n    );\n\n    React.useEffect(() => {\n      // Only updating state to `mounted` if we are using SSR.\n      // This makes it so we don't have an unnecessary re-render when opting out of SSR.\n      setSSRState((state) => (state ? 'mounted' : false));\n    }, []);\n    return (\n      <Context.Provider value={contextValue}>{props.children}</Context.Provider>\n    );\n  };\n\n  function useContext() {\n    const context = React.useContext(Context);\n\n    if (!context) {\n      throw new Error(\n        'Unable to find tRPC Context. Did you forget to wrap your App inside `withTRPC` HoC?',\n      );\n    }\n    return context;\n  }\n\n  /**\n   * Hack to make sure errors return `status`='error` when doing SSR\n   * @see https://github.com/trpc/trpc/pull/1645\n   */\n  function useSSRQueryOptionsIfNeeded<\n    TOptions extends { retryOnMount?: boolean } | undefined,\n  >(queryKey: TRPCQueryKey, opts: TOptions): TOptions {\n    const { queryClient, ssrState } = useContext();\n    return ssrState &&\n      ssrState !== 'mounted' &&\n      queryClient.getQueryCache().find({ queryKey })?.state.status === 'error'\n      ? {\n          retryOnMount: false,\n          ...opts,\n        }\n      : opts;\n  }\n\n  function useQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCQueryResult<unknown, TError> {\n    const context = useContext();\n    const { abortOnUnmount, client, ssrState, queryClient, prefetchQuery } =\n      context;\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchQuery(queryKey, opts as any);\n    }\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? config?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useQuery(\n      {\n        ...ssrOpts,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : async (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              const result = await client.query(\n                ...getClientArgs(queryKey, actualOpts),\n              );\n\n              if (isAsyncIterable(result)) {\n                return buildQueryFromAsyncIterable(\n                  result,\n                  queryClient,\n                  queryKey,\n                );\n              }\n              return result;\n            },\n      },\n      queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n\n  function usePrefetchQuery(\n    path: string[],\n    input: unknown,\n    opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const isInputSkipToken = input === skipToken;\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    _usePrefetchQuery({\n      ...opts,\n      queryKey: queryKey as any,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              trpc: {\n                ...opts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(...getClientArgs(queryKey, actualOpts));\n          },\n    });\n  }\n\n  function useSuspenseQuery(\n    path: readonly string[],\n    input: unknown,\n    opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseQueryResult<unknown, TError> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'query');\n\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ??\n      config?.abortOnUnmount ??\n      context.abortOnUnmount;\n\n    const hook = __useSuspenseQuery(\n      {\n        ...opts,\n        queryKey: queryKey as any,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...opts,\n            trpc: {\n              ...opts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : { signal: null }),\n            },\n          };\n\n          return context.client.query(...getClientArgs(queryKey, actualOpts));\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCQueryResult<unknown, TError>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return [hook.data, hook as any];\n  }\n\n  function useMutation(\n    path: readonly string[],\n    opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>,\n  ): UseTRPCMutationResult<unknown, TError, unknown, unknown> {\n    const { client, queryClient } = useContext();\n\n    const mutationKey = getMutationKeyInternal(path);\n\n    const defaultOpts = queryClient.defaultMutationOptions(\n      queryClient.getMutationDefaults(mutationKey),\n    );\n\n    const hook = __useMutation(\n      {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn: (input) => {\n          return client.mutation(...getClientArgs([path, { input }], opts));\n        },\n        onSuccess(...args) {\n          const originalFn = () =>\n            opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n\n          return mutationSuccessOverride({\n            originalFn,\n            queryClient,\n            meta: opts?.meta ?? defaultOpts?.meta ?? {},\n          });\n        },\n      },\n      queryClient,\n    ) as UseTRPCMutationResult<unknown, TError, unknown, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    return hook;\n  }\n  const initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'> = {\n    data: undefined,\n    error: null,\n    status: 'idle',\n  };\n\n  const initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  > = {\n    data: undefined,\n    error: null,\n    status: 'connecting',\n  };\n\n  /* istanbul ignore next -- @preserve */\n  function useSubscription(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSubscriptionOptions<unknown, TError>,\n  ) {\n    const enabled = opts?.enabled ?? input !== skipToken;\n    const queryKey = hashKey(getQueryKeyInternal(path, input, 'any'));\n    const { client } = useContext();\n\n    const optsRef = React.useRef<typeof opts>(opts);\n    React.useEffect(() => {\n      optsRef.current = opts;\n    });\n\n    type $Result = TRPCSubscriptionResult<unknown, TError>;\n\n    const [trackedProps] = React.useState(new Set<keyof $Result>([]));\n\n    const addTrackedProp = React.useCallback(\n      (key: keyof $Result) => {\n        trackedProps.add(key);\n      },\n      [trackedProps],\n    );\n\n    const currentSubscriptionRef = React.useRef<Unsubscribable>(null);\n\n    const updateState = React.useCallback(\n      (callback: (prevState: $Result) => $Result) => {\n        const prev = resultRef.current;\n        const next = (resultRef.current = callback(prev));\n\n        let shouldUpdate = false;\n        for (const key of trackedProps) {\n          if (prev[key] !== next[key]) {\n            shouldUpdate = true;\n            break;\n          }\n        }\n        if (shouldUpdate) {\n          setState(trackResult(next, addTrackedProp));\n        }\n      },\n      [addTrackedProp, trackedProps],\n    );\n\n    const reset = React.useCallback((): void => {\n      // unsubscribe from the previous subscription\n      currentSubscriptionRef.current?.unsubscribe();\n\n      if (!enabled) {\n        updateState(() => ({ ...initialStateIdle, reset }));\n        return;\n      }\n      updateState(() => ({ ...initialStateConnecting, reset }));\n      const subscription = client.subscription(\n        path.join('.'),\n        input ?? undefined,\n        {\n          onStarted: () => {\n            optsRef.current.onStarted?.();\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              error: null,\n            }));\n          },\n          onData: (data) => {\n            optsRef.current.onData?.(data);\n            updateState((prev) => ({\n              ...prev,\n              status: 'pending',\n              data,\n              error: null,\n            }));\n          },\n          onError: (error) => {\n            optsRef.current.onError?.(error);\n            updateState((prev) => ({\n              ...prev,\n              status: 'error',\n              error,\n            }));\n          },\n          onConnectionStateChange: (result) => {\n            updateState((prev) => {\n              switch (result.state) {\n                case 'idle':\n                  return {\n                    ...prev,\n                    status: result.state,\n                    error: null,\n                    data: undefined,\n                  };\n                case 'connecting':\n                  return {\n                    ...prev,\n                    error: result.error,\n                    status: result.state,\n                  };\n\n                case 'pending':\n                  // handled when data is / onStarted\n                  return prev;\n              }\n            });\n          },\n          onComplete: () => {\n            optsRef.current.onComplete?.();\n\n            // In the case of WebSockets, the connection might not be idle so `onConnectionStateChange` will not be called until the connection is closed.\n            // In this case, we need to set the state to idle manually.\n            updateState((prev) => ({\n              ...prev,\n              status: 'idle',\n              error: null,\n              data: undefined,\n            }));\n\n            // (We might want to add a `connectionState` to the state to track the connection state separately)\n          },\n        },\n      );\n\n      currentSubscriptionRef.current = subscription;\n\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [client, queryKey, enabled, updateState]);\n    React.useEffect(() => {\n      reset();\n\n      return () => {\n        currentSubscriptionRef.current?.unsubscribe();\n      };\n    }, [reset]);\n\n    const resultRef = React.useRef<$Result>(\n      enabled\n        ? { ...initialStateConnecting, reset }\n        : { ...initialStateIdle, reset },\n    );\n\n    const [state, setState] = React.useState<$Result>(\n      trackResult(resultRef.current, addTrackedProp),\n    );\n\n    return state;\n  }\n\n  function useInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCInfiniteQueryResult<unknown, TError, unknown> {\n    const {\n      client,\n      ssrState,\n      prefetchInfiniteQuery,\n      queryClient,\n      abortOnUnmount,\n    } = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    if (\n      typeof window === 'undefined' &&\n      ssrState === 'prepass' &&\n      opts?.trpc?.ssr !== false &&\n      (opts?.enabled ?? defaultOpts?.enabled) !== false &&\n      !isInputSkipToken &&\n      !queryClient.getQueryCache().find({ queryKey })\n    ) {\n      void prefetchInfiniteQuery(queryKey, { ...defaultOpts, ...opts } as any);\n    }\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount = opts?.trpc?.abortOnUnmount ?? abortOnUnmount;\n\n    const hook = __useInfiniteQuery(\n      {\n        ...ssrOpts,\n        initialPageParam: opts.initialCursor ?? null,\n        persister: opts.persister,\n        queryKey: queryKey as any,\n        queryFn: isInputSkipToken\n          ? input\n          : (queryFunctionContext) => {\n              const actualOpts = {\n                ...ssrOpts,\n                trpc: {\n                  ...ssrOpts?.trpc,\n                  ...(shouldAbortOnUnmount\n                    ? { signal: queryFunctionContext.signal }\n                    : { signal: null }),\n                },\n              };\n\n              return client.query(\n                ...getClientArgs(queryKey, actualOpts, {\n                  pageParam:\n                    queryFunctionContext.pageParam ?? opts.initialCursor,\n                  direction: queryFunctionContext.direction,\n                }),\n              );\n            },\n      },\n      queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n    return hook;\n  }\n\n  function usePrefetchInfiniteQuery(\n    path: string[],\n    input: unknown,\n    opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>,\n  ): void {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const isInputSkipToken = input === skipToken;\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    __usePrefetchInfiniteQuery({\n      ...opts,\n      initialPageParam: opts.initialCursor ?? null,\n      queryKey,\n      queryFn: isInputSkipToken\n        ? input\n        : (queryFunctionContext) => {\n            const actualOpts = {\n              ...ssrOpts,\n              trpc: {\n                ...ssrOpts?.trpc,\n                ...(shouldAbortOnUnmount\n                  ? { signal: queryFunctionContext.signal }\n                  : {}),\n              },\n            };\n\n            return context.client.query(\n              ...getClientArgs(queryKey, actualOpts, {\n                pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n                direction: queryFunctionContext.direction,\n              }),\n            );\n          },\n    });\n  }\n\n  function useSuspenseInfiniteQuery(\n    path: readonly string[],\n    input: unknown,\n    opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>,\n  ): UseTRPCSuspenseInfiniteQueryResult<unknown, TError, unknown> {\n    const context = useContext();\n    const queryKey = getQueryKeyInternal(path, input, 'infinite');\n\n    const defaultOpts = context.queryClient.getQueryDefaults(queryKey);\n\n    const ssrOpts = useSSRQueryOptionsIfNeeded(queryKey, {\n      ...defaultOpts,\n      ...opts,\n    });\n\n    // request option should take priority over global\n    const shouldAbortOnUnmount =\n      opts?.trpc?.abortOnUnmount ?? context.abortOnUnmount;\n\n    const hook = __useSuspenseInfiniteQuery(\n      {\n        ...opts,\n        initialPageParam: opts.initialCursor ?? null,\n        queryKey,\n        queryFn: (queryFunctionContext) => {\n          const actualOpts = {\n            ...ssrOpts,\n            trpc: {\n              ...ssrOpts?.trpc,\n              ...(shouldAbortOnUnmount\n                ? { signal: queryFunctionContext.signal }\n                : {}),\n            },\n          };\n\n          return context.client.query(\n            ...getClientArgs(queryKey, actualOpts, {\n              pageParam: queryFunctionContext.pageParam ?? opts.initialCursor,\n              direction: queryFunctionContext.direction,\n            }),\n          );\n        },\n      },\n      context.queryClient,\n    ) as UseTRPCInfiniteQueryResult<unknown, TError, unknown>;\n\n    hook.trpc = useHookResult({\n      path,\n    });\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return [hook.data!, hook as any];\n  }\n\n  const useQueries: TRPCUseQueries<TRouter> = (queriesCallback, options) => {\n    const { ssrState, queryClient, prefetchQuery, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    if (typeof window === 'undefined' && ssrState === 'prepass') {\n      for (const query of queries) {\n        const queryOption = query as TRPCQueryOptions<any, any>;\n        if (\n          queryOption.trpc?.ssr !== false &&\n          !queryClient.getQueryCache().find({ queryKey: queryOption.queryKey })\n        ) {\n          void prefetchQuery(queryOption.queryKey, queryOption as any);\n        }\n      }\n    }\n\n    return __useQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n        combine: options?.combine as any,\n      },\n      queryClient,\n    );\n  };\n\n  const useSuspenseQueries: TRPCUseSuspenseQueries<TRouter> = (\n    queriesCallback,\n  ) => {\n    const { queryClient, client } = useContext();\n\n    const proxy = createUseQueries(client);\n\n    const queries = queriesCallback(proxy);\n\n    const hook = __useSuspenseQueries(\n      {\n        queries: queries.map((query) => ({\n          ...query,\n          queryFn: query.queryFn,\n          queryKey: (query as TRPCQueryOptions<any, any>).queryKey,\n        })),\n      },\n      queryClient,\n    );\n\n    return [hook.map((h) => h.data), hook] as any;\n  };\n\n  return {\n    Provider: TRPCProvider,\n    createClient,\n    useContext,\n    useUtils: useContext,\n    useQuery,\n    usePrefetchQuery,\n    useSuspenseQuery,\n    useQueries,\n    useSuspenseQueries,\n    useMutation,\n    useSubscription,\n    useInfiniteQuery,\n    usePrefetchInfiniteQuery,\n    useSuspenseInfiniteQuery,\n  };\n}\n\n/**\n * Infer the type of a `createReactQueryHooks` function\n * @internal\n */\nexport type CreateReactQueryHooks<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n> = ReturnType<typeof createRootHooks<TRouter, TSSRContext>>;\n", "import type { QueryClientConfig } from '@tanstack/react-query';\nimport { QueryClient } from '@tanstack/react-query';\n\n/**\n * @internal\n */\nexport type CreateTRPCReactQueryClientConfig =\n  | {\n      queryClient?: QueryClient;\n      queryClientConfig?: never;\n    }\n  | {\n      queryClientConfig?: QueryClientConfig;\n      queryClient?: never;\n    };\n\n/**\n * @internal\n */\nexport const getQueryClient = (config: CreateTRPCReactQueryClientConfig) =>\n  config.queryClient ?? new QueryClient(config.queryClientConfig);\n", "import type {\n  DefinedInitialDataInfiniteOptions,\n  DefinedUseInfiniteQueryResult,\n  InfiniteData,\n  SkipToken,\n  UndefinedInitialDataInfiniteOptions,\n  UseInfiniteQueryOptions,\n  UseInfiniteQueryResult,\n  UseSuspenseInfiniteQueryOptions,\n  UseSuspenseInfiniteQueryResult,\n  UseSuspenseQueryResult,\n} from '@tanstack/react-query';\nimport type { createTRPCClient, TRPCClientErrorLike } from '@trpc/client';\nimport type {\n  AnyProcedure,\n  AnyRootTypes,\n  AnyRouter,\n  inferAsyncIterableYield,\n  inferProcedureInput,\n  inferTransformedProcedureOutput,\n  ProcedureType,\n  ProtectedIntersection,\n  RouterRecord,\n  Simplify,\n} from '@trpc/server/unstable-core-do-not-import';\nimport { createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport * as React from 'react';\nimport type {\n  TRPCUseQueries,\n  TRPCUseSuspenseQueries,\n} from './internals/useQueries';\nimport type {\n  CreateReactUtils,\n  TRPCFetchInfiniteQueryOptions,\n  TRPCFetchQueryOptions,\n} from './shared';\nimport { createReactDecoration, createReactQueryUtils } from './shared';\nimport type { CreateReactQueryHooks } from './shared/hooks/createHooksInternal';\nimport { createRootHooks } from './shared/hooks/createHooksInternal';\nimport type {\n  DefinedUseTRPCQueryOptions,\n  DefinedUseTRPCQueryResult,\n  TRPCHookResult,\n  TRPCProvider,\n  TRPCSubscriptionResult,\n  TRPCUseQueryBaseOptions,\n  UseTRPCMutationOptions,\n  UseTRPCMutationResult,\n  UseTRPCQueryOptions,\n  UseTRPCQueryResult,\n  UseTRPCSubscriptionOptions,\n  UseTRPCSuspenseQueryOptions,\n} from './shared/hooks/types';\nimport type { CreateTRPCReactOptions } from './shared/types';\n\ntype ResolverDef = {\n  input: any;\n  output: any;\n  transformer: boolean;\n  errorShape: any;\n};\n/**\n * @internal\n */\nexport interface ProcedureUseQuery<TDef extends ResolverDef> {\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts: DefinedUseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<{\n        errorShape: TDef['errorShape'];\n        transformer: TDef['transformer'];\n      }>,\n      TDef['output']\n    >,\n  ): DefinedUseTRPCQueryResult<\n    TData,\n    TRPCClientErrorLike<{\n      errorShape: TDef['errorShape'];\n      transformer: TDef['transformer'];\n    }>\n  >;\n\n  <TQueryFnData extends TDef['output'] = TDef['output'], TData = TQueryFnData>(\n    input: TDef['input'] | SkipToken,\n    opts?: UseTRPCQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>,\n      TDef['output']\n    >,\n  ): UseTRPCQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n/**\n * @internal\n */\nexport type ProcedureUsePrefetchQuery<TDef extends ResolverDef> = (\n  input: TDef['input'] | SkipToken,\n  opts?: TRPCFetchQueryOptions<TDef['output'], TRPCClientErrorLike<TDef>>,\n) => void;\n\n/**\n * @remark `void` is here due to https://github.com/trpc/trpc/pull/4374\n */\ntype CursorInput = {\n  cursor?: any;\n} | void;\n\ntype ReservedInfiniteQueryKeys = 'cursor' | 'direction';\ntype InfiniteInput<TInput> =\n  | Omit<TInput, ReservedInfiniteQueryKeys>\n  | SkipToken;\n\ntype inferCursorType<TInput> = TInput extends { cursor?: any }\n  ? TInput['cursor']\n  : unknown;\n\ntype makeInfiniteQueryOptions<TCursor, TOptions> = Omit<\n  TOptions,\n  'queryKey' | 'initialPageParam' | 'queryFn' | 'queryHash' | 'queryHashFn'\n> &\n  TRPCUseQueryBaseOptions & {\n    initialCursor?: TCursor;\n  };\n\ntype trpcInfiniteData<TDef extends ResolverDef> = Simplify<\n  InfiniteData<TDef['output'], inferCursorType<TDef['input']>>\n>;\n// references from react-query\n// 1st\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: DefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): DefinedUseInfiniteQueryResult<TData, TError>;\n// 2nd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UndefinedInitialDataInfiniteOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n// 3rd\n// declare function useInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseInfiniteQueryResult<TData, TError>;\n\nexport interface useTRPCInfiniteQuery<TDef extends ResolverDef> {\n  // 1st\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      DefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult &\n    DefinedUseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 2nd\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UndefinedInitialDataInfiniteOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n\n  // 3rd:\n  <TData = trpcInfiniteData<TDef>>(\n    input: InfiniteInput<TDef['input']>,\n    opts?: makeInfiniteQueryOptions<\n      inferCursorType<TDef['input']>,\n      UseInfiniteQueryOptions<\n        //     TQueryFnData,\n        TDef['output'],\n        //     TError,\n        TRPCClientErrorLike<TDef>,\n        //     TData,\n        TData,\n        //     TQueryKey,\n        any,\n        //     TPageParam\n        inferCursorType<TDef['input']>\n      >\n    >,\n  ): TRPCHookResult & UseInfiniteQueryResult<TData, TRPCClientErrorLike<TDef>>;\n}\n\n// references from react-query\n// declare function useSuspenseInfiniteQuery<\n//   TQueryFnData,\n//   TError = DefaultError,\n//   TData = InfiniteData<TQueryFnData>,\n//   TQueryKey extends QueryKey = QueryKey,\n//   TPageParam = unknown,\n// >(\n//   options: UseSuspenseInfiniteQueryOptions<\n//     TQueryFnData,\n//     TError,\n//     TData,\n//     TQueryFnData,\n//     TQueryKey,\n//     TPageParam\n//   >,\n//   queryClient?: QueryClient,\n// ): UseSuspenseInfiniteQueryResult<TData, TError>;\n\nexport type useTRPCSuspenseInfiniteQuery<TDef extends ResolverDef> = (\n  input: InfiniteInput<TDef['input']>,\n  opts: makeInfiniteQueryOptions<\n    inferCursorType<TDef['input']>,\n    UseSuspenseInfiniteQueryOptions<\n      //     TQueryFnData,\n      TDef['output'],\n      //     TError,\n      TRPCClientErrorLike<TDef>,\n      //     TData,\n      trpcInfiniteData<TDef>,\n      //     TQueryKey,\n      any,\n      //     TPageParam\n      inferCursorType<TDef['input']>\n    >\n  >,\n) => [\n  trpcInfiniteData<TDef>,\n  TRPCHookResult &\n    UseSuspenseInfiniteQueryResult<\n      trpcInfiniteData<TDef>,\n      TRPCClientErrorLike<TDef>\n    >,\n];\n\n/**\n * @internal\n */\nexport type MaybeDecoratedInfiniteQuery<TDef extends ResolverDef> =\n  TDef['input'] extends CursorInput\n    ? {\n        /**\n         * @see https://trpc.io/docs/v11/client/react/useInfiniteQuery\n         */\n        useInfiniteQuery: useTRPCInfiniteQuery<TDef>;\n        /**\n         * @see https://trpc.io/docs/client/react/suspense#usesuspenseinfinitequery\n         */\n        useSuspenseInfiniteQuery: useTRPCSuspenseInfiniteQuery<TDef>;\n\n        usePrefetchInfiniteQuery: (\n          input: Omit<TDef['input'], ReservedInfiniteQueryKeys> | SkipToken,\n          opts: TRPCFetchInfiniteQueryOptions<\n            TDef['input'],\n            TDef['output'],\n            TRPCClientErrorLike<TDef>\n          >,\n        ) => void;\n      }\n    : object;\n\n/**\n * @internal\n */\nexport type DecoratedQueryMethods<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useQuery\n   */\n  useQuery: ProcedureUseQuery<TDef>;\n  usePrefetchQuery: ProcedureUsePrefetchQuery<TDef>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/suspense#usesuspensequery\n   */\n  useSuspenseQuery: <\n    TQueryFnData extends TDef['output'] = TDef['output'],\n    TData = TQueryFnData,\n  >(\n    input: TDef['input'],\n    opts?: UseTRPCSuspenseQueryOptions<\n      TQueryFnData,\n      TData,\n      TRPCClientErrorLike<TDef>\n    >,\n  ) => [\n    TData,\n    UseSuspenseQueryResult<TData, TRPCClientErrorLike<TDef>> & TRPCHookResult,\n  ];\n};\n\n/**\n * @internal\n */\nexport type DecoratedQuery<TDef extends ResolverDef> =\n  MaybeDecoratedInfiniteQuery<TDef> & DecoratedQueryMethods<TDef>;\n\nexport type DecoratedMutation<TDef extends ResolverDef> = {\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useMutation\n   */\n  useMutation: <TContext = unknown>(\n    opts?: UseTRPCMutationOptions<\n      TDef['input'],\n      TRPCClientErrorLike<TDef>,\n      TDef['output'],\n      TContext\n    >,\n  ) => UseTRPCMutationResult<\n    TDef['output'],\n    TRPCClientErrorLike<TDef>,\n    TDef['input'],\n    TContext\n  >;\n};\n\ninterface ProcedureUseSubscription<TDef extends ResolverDef> {\n  // Without skip token\n  (\n    input: TDef['input'],\n    opts?: UseTRPCSubscriptionOptions<\n      inferAsyncIterableYield<TDef['output']>,\n      TRPCClientErrorLike<TDef>\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n\n  // With skip token\n  (\n    input: TDef['input'] | SkipToken,\n    opts?: Omit<\n      UseTRPCSubscriptionOptions<\n        inferAsyncIterableYield<TDef['output']>,\n        TRPCClientErrorLike<TDef>\n      >,\n      'enabled'\n    >,\n  ): TRPCSubscriptionResult<\n    inferAsyncIterableYield<TDef['output']>,\n    TRPCClientErrorLike<TDef>\n  >;\n}\n/**\n * @internal\n */\nexport type DecorateProcedure<\n  TType extends ProcedureType,\n  TDef extends ResolverDef,\n> = TType extends 'query'\n  ? DecoratedQuery<TDef>\n  : TType extends 'mutation'\n    ? DecoratedMutation<TDef>\n    : TType extends 'subscription'\n      ? {\n          /**\n           * @see https://trpc.io/docs/v11/subscriptions\n           */\n          useSubscription: ProcedureUseSubscription<TDef>;\n        }\n      : never;\n\n/**\n * @internal\n */\nexport type DecorateRouterRecord<\n  TRoot extends AnyRootTypes,\n  TRecord extends RouterRecord,\n> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends AnyProcedure\n      ? DecorateProcedure<\n          $Value['_def']['type'],\n          {\n            input: inferProcedureInput<$Value>;\n            output: inferTransformedProcedureOutput<TRoot, $Value>;\n            transformer: TRoot['transformer'];\n            errorShape: TRoot['errorShape'];\n          }\n        >\n      : $Value extends RouterRecord\n        ? DecorateRouterRecord<TRoot, $Value>\n        : never\n    : never;\n};\n\n/**\n * @internal\n */\nexport type CreateTRPCReactBase<TRouter extends AnyRouter, TSSRContext> = {\n  /**\n   * @deprecated renamed to `useUtils` and will be removed in a future tRPC version\n   *\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useContext(): CreateReactUtils<TRouter, TSSRContext>;\n  /**\n   * @see https://trpc.io/docs/v11/client/react/useUtils\n   */\n  useUtils(): CreateReactUtils<TRouter, TSSRContext>;\n  Provider: TRPCProvider<TRouter, TSSRContext>;\n  createClient: typeof createTRPCClient<TRouter>;\n  useQueries: TRPCUseQueries<TRouter>;\n  useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>;\n};\n\nexport type CreateTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext,\n> = ProtectedIntersection<\n  CreateTRPCReactBase<TRouter, TSSRContext>,\n  DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >\n>;\n\n/**\n * @internal\n */\nexport function createHooksInternal<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(trpc: CreateReactQueryHooks<TRouter, TSSRContext>) {\n  type CreateHooksInternal = CreateTRPCReact<TRouter, TSSRContext>;\n\n  const proxy = createReactDecoration<TRouter, TSSRContext>(\n    trpc,\n  ) as DecorateRouterRecord<\n    TRouter['_def']['_config']['$types'],\n    TRouter['_def']['record']\n  >;\n  return createFlatProxy<CreateHooksInternal>((key) => {\n    if (key === 'useContext' || key === 'useUtils') {\n      return () => {\n        const context = trpc.useUtils();\n        // create a stable reference of the utils context\n        return React.useMemo(() => {\n          return (createReactQueryUtils as any)(context);\n        }, [context]);\n      };\n    }\n\n    if (trpc.hasOwnProperty(key)) {\n      return (trpc as any)[key];\n    }\n\n    return proxy[key];\n  });\n}\n\nexport function createTRPCReact<\n  TRouter extends AnyRouter,\n  TSSRContext = unknown,\n>(\n  opts?: CreateTRPCReactOptions<TRouter>,\n): CreateTRPCReact<TRouter, TSSRContext> {\n  const hooks = createRootHooks<TRouter, TSSRContext>(opts);\n  const proxy = createHooksInternal<TRouter, TSSRContext>(hooks);\n\n  return proxy as any;\n}\n", "import type { AnyRouter } from '@trpc/server/unstable-core-do-not-import';\nimport { createQueryUtilsProxy } from './shared';\nimport type { CreateQueryUtilsOptions } from './utils/createUtilityFunctions';\nimport { createUtilityFunctions } from './utils/createUtilityFunctions';\n\nexport function createTRPCQueryUtils<TRouter extends AnyRouter>(\n  opts: CreateQueryUtilsOptions<TRouter>,\n) {\n  const utils = createUtilityFunctions(opts);\n  return createQueryUtilsProxy<TRouter>(utils);\n}\n"],
  "mappings": "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",
  "names": ["_objectWithoutProperties", "_typeof", "o", "toPrimitive", "toPropertyKey", "r", "path: readonly string[]", "input: unknown", "type: QueryType", "procedureOrRouter: TProcedureOrRouter", "procedure: TProcedure", "hooks: CreateReactQueryHooks<TRouter, TSSRContext>", "contextProps: (keyof TRPCContextPropsBase<any, any>)[]", "utilName: keyof AnyDecoratedProcedure", "context: TRPCQueryUtils<TRouter>", "contextMap: Record<keyof AnyDecoratedProcedure, () => unknown>", "context: TRPCContextState<AnyRouter, TSSRContext>", "client: TRPCUntypedClient<TRouter> | TRPCClient<TRouter>", "untypedClient: TRPCUntypedClient<TRouter>", "options: QueryOptions", "queryKey: TRPCQueryKey", "opts: TOptions", "infiniteParams?: {\n    pageParam: any;\n    direction: 'forward' | 'backward';\n  }", "_asyncIterator", "r", "AsyncFromSyncIterator", "value: {\n  path: readonly string[];\n}", "asyncIterable: AsyncIterable<unknown>", "queryClient: QueryClient", "aggregate: unknown[]", "opts: CreateQueryUtilsOptions<TRouter>", "opts", "queryFnContext: QueryFunctionContext<TRPCQueryKey, unknown>", "queryFnContext: QueryFunctionContext<TRPCQueryKey>", "input: unknown", "result: T", "onTrackResult: (key: keyof T) => void", "config?: CreateTRPCReactOptions<TRouter>", "mutationSuccessOverride: UseMutationOverride['onSuccess']", "TRPCProvider: TRPCProvider<TRouter, TSSRContext>", "client: TRPCUntypedClient<TRouter>", "import_objectSpread2", "useContext", "useQuery", "path: readonly string[]", "opts?: UseTRPCQueryOptions<unknown, unknown, TError>", "usePrefetchQuery", "path: string[]", "opts?: UseTRPCPrefetchQueryOptions<unknown, unknown, TError>", "useSuspenseQuery", "opts?: UseTRPCSuspenseQueryOptions<unknown, unknown, TError>", "useMutation", "opts?: UseTRPCMutationOptions<unknown, TError, unknown, unknown>", "initialStateIdle: Omit<TRPCSubscriptionIdleResult<unknown>, 'reset'>", "initialStateConnecting: Omit<\n    TRPCSubscriptionConnectingResult<unknown, TError>,\n    'reset'\n  >", "opts: UseTRPCSubscriptionOptions<unknown, TError>", "key: keyof $Result", "callback: (prevState: $Result) => $Result", "useInfiniteQuery", "opts: UseTRPCInfiniteQueryOptions<unknown, unknown, TError>", "usePrefetchInfiniteQuery", "opts: UseTRPCPrefetchInfiniteQueryOptions<unknown, unknown, TError>", "useSuspenseInfiniteQuery", "opts: UseTRPCSuspenseInfiniteQueryOptions<unknown, unknown, TError>", "useQueries: TRPCUseQueries<TRouter>", "useSuspenseQueries: TRPCUseSuspenseQueries<TRouter>", "trpc: CreateReactQueryHooks<TRouter, TSSRContext>", "opts?: CreateTRPCReactOptions<TRouter>", "opts: CreateQueryUtilsOptions<TRouter>"]
}
